# global options
{
	admin off
	persist_config off
	auto_https off

	# Order directives - geoip2_vars must come first to set variables
	order geoip2_vars first
	order rate_limit before basic_auth

	# runtime logs
	log {
		format json
	}

	# server options
	servers {
		# Trust all proxies since Railway's edge proxies don't have static IPs
		trusted_proxies static 0.0.0.0/0 ::/0
		# Use strict mode to parse X-Forwarded-For from right-to-left (more secure)
		trusted_proxies_strict
	}

	# GeoIP2 database configuration
	geoip2 {
		databaseDirectory "/usr/share/GeoIP/"
		editionID "GeoLite2-Country"
	}
}

(lb_settings) {
	lb_policy round_robin
	lb_retries 100
	lb_try_duration 10s
	lb_try_interval 250ms
}

(passive_health_checks) {
	fail_duration 60s
	max_fails 300
	unhealthy_latency 5s
	unhealthy_request_count 200
}

# Security headers
(security_headers) {
	header {
		X-Frame-Options "SAMEORIGIN"
		X-Content-Type-Options "nosniff"
		X-XSS-Protection "1; mode=block"
		Referrer-Policy "strict-origin-when-cross-origin"
		-Server
	}
}

# Rate limiting snippet
(rate_limiting) {
	rate_limit {
		zone general {
			key {client_ip}
			events 200
			window 1m
		}

		zone api {
			match {
				path /api/*
			}
			key {client_ip}
			events 100
			window 1m
		}

		zone auth {
			match {
				path /oauth2/* /login/*
			}
			key {client_ip}
			events 10
			window 1m
		}

		zone login_strict {
			match {
				path /oauth2/authorization/* /login/oauth2/code/*
			}
			key {client_ip}
			events 5
			window 5m
		}

		log_key
		jitter 0.2
	}
}

# site block
:{$PORT} {
	log {
		format json
	}

	# IMPORTANT: Initialize geoip2 variables FIRST for ALL requests
	# This must run before any matchers that use geoip2 variables
	geoip2_vars trusted_proxies

	# Apply security headers globally
	import security_headers

	# Debug endpoint
	route /debug/ip {
		respond "Remote IP: {remote_host}
Client IP: {client_ip}
X-Forwarded-For: {header.X-Forwarded-For}
X-Real-IP: {header.X-Real-IP}
GeoIP Country: {geoip2.country_code}
GeoIP Country Name: {geoip2.country_name}"
	}

	# Geo-blocking - block if NOT in Scandinavia AND NOT private IP
	@blocked_geo {
		not expression `{geoip2.country_code} in ["NO", "SE", "DK", "FI", "IS"]`
		not remote_ip private_ranges
		not path /debug/ip
	}
	respond @blocked_geo "Access denied - this service is only available in Scandinavia (detected: {geoip2.country_code})" 403

	# Apply rate limiting
	import rate_limiting

	# OAuth2 paths must go to backend
	handle /oauth2/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# OAuth2 callback must go to backend
	handle /login/oauth2/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# API paths go to backend - handle_path strips the /api prefix
	handle_path /api/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# Catch-all: proxy everything else to frontend
	handle {
		reverse_proxy {
			dynamic a {
				name {$FRONTEND_DOMAIN}
				port {$FRONTEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}
}
