# global options
{
	admin off
	persist_config off
	auto_https off

	# Order directives - geoip2_vars must come first to set variables
	order geoip2_vars first
	order rate_limit before basic_auth

	# runtime logs
	log {
		format json
	}

	# server options
	servers {
		# Trust all proxies since Railway's edge proxies don't have static IPs
		trusted_proxies static 0.0.0.0/0 ::/0
		# Use strict mode to parse X-Forwarded-For from right-to-left (more secure)
		trusted_proxies_strict
	}

	# GeoIP2 database configuration
	geoip2 {
		databaseDirectory "/usr/share/GeoIP/"
		editionID "GeoLite2-Country"
	}
}

(lb_settings) {
	lb_policy round_robin
	lb_retries 100
	lb_try_duration 10s
	lb_try_interval 250ms
}

(passive_health_checks) {
	fail_duration 60s
	max_fails 300
	unhealthy_latency 5s
	unhealthy_request_count 200
}

# Geo-blocking snippet - allows only Scandinavian countries
# NO = Norway, SE = Sweden, DK = Denmark, FI = Finland, IS = Iceland
# Uses caddy-geoip2 which respects trusted_proxies for X-Forwarded-For parsing
(geo_block_scandinavia) {
	# Use trusted_proxies mode to respect X-Forwarded-For header
	geoip2_vars trusted_proxies

	# Block if NOT in Scandinavia AND NOT from private IP ranges
	@blocked_geo {
		not expression `{geoip2.country_code} in ["NO", "SE", "DK", "FI", "IS"]`
		not remote_ip private_ranges
	}
	respond @blocked_geo "Access denied - this service is only available in Scandinavia (detected country: {geoip2.country_code})" 403
}

# Rate limiting snippet - configurable limits
(rate_limiting) {
	rate_limit {
		# Zone for general requests - 100 requests per minute per IP
		zone general {
			key {client_ip}
			events 100
			window 1m
		}

		# Stricter zone for API endpoints - 30 requests per minute per IP
		zone api {
			match {
				path /api/*
			}
			key {client_ip}
			events 30
			window 1m
		}

		# Very strict zone for auth endpoints - 10 requests per minute per IP
		zone auth {
			match {
				path /oauth2/* /login/*
			}
			key {client_ip}
			events 10
			window 1m
		}

		log_key
		jitter 0.2
	}
}

# site block
:{$PORT} {
	log {
		format json
	}

	# Debug endpoint - shows what IP Caddy sees
	route /debug/ip {
		geoip2_vars trusted_proxies
		respond "Remote IP: {remote_host}
Client IP: {client_ip}
X-Forwarded-For: {header.X-Forwarded-For}
X-Real-IP: {header.X-Real-IP}
GeoIP Country: {geoip2.country_code}
GeoIP Country Name: {geoip2.country_name}"
	}

	# Apply geo-blocking (skip for debug endpoint)
	@not_debug not path /debug/ip
	handle @not_debug {
		import geo_block_scandinavia
	}

	# Apply rate limiting
	import rate_limiting

	# OAuth2 paths must go to backend
	handle /oauth2/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# OAuth2 callback must go to backend
	handle /login/oauth2/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# proxy all requests for /* to the frontend
	reverse_proxy {
		dynamic a {
			name {$FRONTEND_DOMAIN}
			port {$FRONTEND_PORT}
			refresh 1s
			dial_timeout 30s
			versions ipv4 ipv6
		}
		import lb_settings
		import passive_health_checks
		header_up Host {upstream_hostport}
	}

	# handle_path strips the prefix before proxying
	handle_path {$BACKEND_PATH:/api}/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}
}
