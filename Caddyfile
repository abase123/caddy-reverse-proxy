# global options
{
	admin off
	persist_config off
	auto_https off

	# Order directives - geoip2_vars must come first to set variables
	order geoip2_vars first
	order rate_limit before basic_auth

	# runtime logs
	log {
		format json
	}

	# server options
	servers {
		# Trust all proxies since Railway's edge proxies don't have static IPs
		trusted_proxies static 0.0.0.0/0 ::/0
		# Use strict mode to parse X-Forwarded-For from right-to-left (more secure)
		trusted_proxies_strict
	}

	# GeoIP2 database configuration
	geoip2 {
		databaseDirectory "/usr/share/GeoIP/"
		editionID "GeoLite2-Country"
	}
}

(lb_settings) {
	lb_policy round_robin
	lb_retries 100
	lb_try_duration 10s
	lb_try_interval 250ms
}

(passive_health_checks) {
	fail_duration 60s
	max_fails 300
	unhealthy_latency 5s
	unhealthy_request_count 200
}

# Security headers
(security_headers) {
	header {
		# Prevent clickjacking
		X-Frame-Options "SAMEORIGIN"
		# Prevent MIME type sniffing
		X-Content-Type-Options "nosniff"
		# XSS protection (legacy browsers)
		X-XSS-Protection "1; mode=block"
		# Referrer policy
		Referrer-Policy "strict-origin-when-cross-origin"
		# Remove server identification
		-Server
	}
}

# Geo-blocking snippet - allows only Scandinavian countries
# NO = Norway, SE = Sweden, DK = Denmark, FI = Finland, IS = Iceland
(geo_block_scandinavia) {
	# Use trusted_proxies mode to respect X-Forwarded-For header
	geoip2_vars trusted_proxies

	# Block if NOT in Scandinavia AND NOT from private IP ranges
	@blocked_geo {
		not expression `{geoip2.country_code} in ["NO", "SE", "DK", "FI", "IS"]`
		not remote_ip private_ranges
	}
	respond @blocked_geo "Access denied - this service is only available in Scandinavia" 403
}

# Rate limiting snippet - configurable limits
(rate_limiting) {
	rate_limit {
		# Zone for general requests - 200 requests per minute per IP
		zone general {
			key {client_ip}
			events 200
			window 1m
		}

		# Zone for API endpoints - 100 requests per minute per IP
		# Suitable for SPAs that make multiple API calls on page load
		zone api {
			match {
				path /api/*
			}
			key {client_ip}
			events 100
			window 1m
		}

		# Strict zone for auth endpoints - 10 requests per minute per IP
		# Protects against brute-force login attempts
		zone auth {
			match {
				path /oauth2/* /login/*
			}
			key {client_ip}
			events 10
			window 1m
		}

		# Burst zone for login specifically - 5 attempts per 5 minutes
		zone login_strict {
			match {
				path /oauth2/authorization/* /login/oauth2/code/*
			}
			key {client_ip}
			events 5
			window 5m
		}

		log_key
		jitter 0.2
	}
}

# site block
:{$PORT} {
	log {
		format json
	}

	# Apply security headers globally
	import security_headers

	# Debug endpoint - protected, only in non-production or remove entirely
	# Consider removing this block in production!
	@debug_allowed {
		path /debug/ip
		# Optionally restrict to specific IPs:
		# remote_ip 80.232.78.94
	}
	route @debug_allowed {
		geoip2_vars trusted_proxies
		respond "Remote IP: {remote_host}
Client IP: {client_ip}
X-Forwarded-For: {header.X-Forwarded-For}
X-Real-IP: {header.X-Real-IP}
GeoIP Country: {geoip2.country_code}
GeoIP Country Name: {geoip2.country_name}"
	}

	# Apply geo-blocking (skip for debug endpoint)
	@not_debug not path /debug/ip
	handle @not_debug {
		import geo_block_scandinavia
	}

	# Apply rate limiting
	import rate_limiting

	# OAuth2 paths must go to backend
	handle /oauth2/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# OAuth2 callback must go to backend
	handle /login/oauth2/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# API paths go to backend - handle_path strips the /api prefix
	handle_path /api/* {
		reverse_proxy {
			dynamic a {
				name {$BACKEND_DOMAIN}
				port {$BACKEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}

	# Catch-all: proxy everything else to frontend
	handle {
		reverse_proxy {
			dynamic a {
				name {$FRONTEND_DOMAIN}
				port {$FRONTEND_PORT}
				refresh 1s
				dial_timeout 30s
				versions ipv4 ipv6
			}
			import lb_settings
			import passive_health_checks
			header_up Host {upstream_hostport}
		}
	}
}
